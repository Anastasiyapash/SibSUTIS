{
Лабораторная работа № 3  Генерация перестановок
Дано конечное множество A. Требуется сгенерировать все возможные перестановки его элементов в лексикографическом порядке. Требования к заданию множества – те же, что в предыдущих лабораторных работах.
Программа должна сначала упорядочить все элементы заданного множества по возрастанию (это первый – минимальный – набор), затем – посредством МИНИМАЛЬНО ВОЗМОЖНЫХ ПЕРЕСТАНОВОК! – сгенерировать последовательно возрастающие (лексикографически) наборы, вплоть до последнего, в котором все элементы упорядочены по убыванию.
Дополнительно: 
1) Предоставить пользователю возможность выбора другого варианта работы программы, в котором за исходную точку упорядочивания наборов выбирается не минимальный набор, а тот, который задан пользователем. 
2) Оценивать количество возможных перестановок и в случае, если они не поместятся на экран, выполнять их вывод в файл с выдачей на экран соответствующей информации для пользователя или выполнять поэкранный вывод с ожиданием нажатия клавиши.
Возможный алгоритм решения (Пример: множество А=1,2,3,4,5,6, |A| = n):
Предположим, что уже построено m наборов. Тогда для получения m+1-го набора:
1) Выполняется проверка последнего (m-го) набора на наличие в его конце некоторого количества символов, упорядоченных по убыванию – пусть это символы ak+1…an. 	
		3 5 2 6 4 1 – k=3, символы с 4-го по 6-й упорядочены по убыванию.
2) Если такое k найдено, то поменять местами k-й элемент и наименьший элемент из ak+1…an, больший этого ak. 	
		В нашем примере это 2 и 4: 3 5 4 6 2 1. 
3) После шага 2 упорядочить элементы с k+1-го до последнего по возрастанию. Получен очередной набор  выдать его на печать. 	
		3 5 4 1 2 6.
4) Если на шаге 1 ответ отрицательный, то поменять местами 2 последних элемента и выдать на печать полученный набор. В частности, после шага 3 это неизбежное действие, т.к. все последние элементы были размещены по возрастанию  целесообразно после выполнения ш.3 задавать признак его выполнения, который будет анализироваться (и сбрасываться) на шаге 1. 		После шага 3 было 3 5 4 1 2 6  выдать 3 5 4 1 6 2. 	
		Если был набор 3 5 2 6 1 4  выдать 3 5 2 6 4 1. 
5) Возврат на шаг 1.
}

program lab3;

uses
  Crt;

const
  Output_File_Name = 'output.txt';  { Имя файла, для вывода перестановок }
  Nmax = 12; { Макс. кол-во элементов множества }

type
  T = Char; { Тип элементов множества }
  TArray = Array[1..Nmax] of T;

var
  F: Text;
  Flag: Boolean; { При Flag = True производится запись в файл }

{ Печать перестановки }
procedure Print(const A: TArray; const N: Integer);
var
  i: Integer;
begin
  for i := 1 to N do begin
    Write(A[i], ' ');
    if Flag then Write(F, A[i], ' ');
  end;
  if WhereY = 25 then ReadKey;
  WriteLn;
  if Flag then WriteLn(F);
end;

{ Сортировка выбором по неубыванию }
procedure Sort(var A: TArray; const N: Integer);
var
  i, j, k: Integer;
  tmp: T;
begin
  for i := 1 to N - 1 do begin
    k := i;
    for j := i + 1 to N do
      if A[j] < A[k] then k := j;
    tmp := A[i];
    A[i] := A[k];
    A[k] := tmp;
  end;
end;

{ Генератор перестановок }
procedure Generate(A: TArray; const N: Integer);
var
  p, q, i, k, m: Integer;
  min: T;
  tmp: T;
begin
  while True do begin
    Print(A, N);
    { Ищем крайний справа A[p], такой, что A[p] < A[p+1] }
    p := 0;
    for i := n downto 2 do
      if A[i - 1] < A[i] then begin
        p := i - 1;
        Break;
      end;
    if p = 0 then Exit; { Если не нашли, то все перестановки уже получены }
    { Ищем минимальный A[q] среди A[p+1], ..., A[n], такой, что A[q] > A[p] }
    min := High(min);
    q:= 0;
    for i := p + 1 to N do
      if (min > A[i]) and (A[i] > A[p]) then begin
        min := A[i];
        q := i;
      end;
    { Меняем местами A[p] и A[q] }
    tmp := A[p];
    A[p] := A[q];
    A[q] := tmp;
    { Инвертируем A[p+1], ..., A[n] }
    k := n + (p + 1) - 1;
    m := k div 2;
    for i := p + 1 to m do begin
      tmp := A[i];
      A[i] := A[k - i + 1];
      A[k - i + 1] := tmp;
    end;
  end;
end;

var
  A: TArray;
  N: Integer;
begin
  ClrScr;
  WriteLn('Введите множество элементов через пробел (все элементы должны быть различны).');
  N := 0;
  while not SeekEoLn do begin
    Inc(N);
    Read(A[N]);
  end;
  Sort(A, N);
  Flag := False;
  if N > 3 then begin
    ClrScr;
    WriteLn('Невозможно отобразить все перестановки на экране. Нажмите любую клавишу ');
    WriteLn('для вывода следующей перестановки. Будет произведена запись в файл.');
    Assign(F, Output_File_Name);
    Rewrite(F);
    Flag := True;
  end;
  WriteLn;
  Generate(A, N);
  if Flag then Close(F);
  WriteLn('Выполнено.');
  ReadKey;
end.
